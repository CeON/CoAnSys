/*
 * (C) 2010-2012 ICM UW. All rights reserved.
 */
package pl.edu.icm.coansys.importers;

import java.io.File;
import java.io.FilenameFilter;
import java.io.IOException;
import java.io.InputStream;
import java.util.Iterator;
import java.util.List;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import pl.edu.icm.coansys.importers.DocumentProtos.DocumentMetadata;
import pl.edu.icm.synat.application.model.bwmeta.YContentEntry;
import pl.edu.icm.synat.application.model.bwmeta.YElement;
import pl.edu.icm.synat.application.model.bwmeta.YExportable;

/**
 *
 * @author Artur Czeczko a.czeczko@icm.edu.pl
 */
public class ZipDirToProtos implements Iterable<DocumentMetadata.Builder> {
    /*
     * The directory contains multiple zip files. Every zip file can contain
     * multiple xml files. Every xml file can contain multiple YExportable
     * objects. An iterator of this class walks through every zip file, then
     * every xml file and every YExportable object. Output type
     * DocumentMetadata.Builder is a class generated by protocol buffers
     * compiler.
     */

    private static final Logger logger = LoggerFactory.getLogger(ZipDirToProtos.class);
    //List of zip files to process and actual position in this list
    private File[] listZipFiles;
    private int zipIndex;
    //A zip archive we are processing
    private ZipArchive actualZipArchive = null;
    //Markers of actual position in archive
    private Iterator<String> xmlPathIterator = null;
    private Iterator<YExportable> yExportableIterator = null;
    //An object which will be returned by next call of iterators next() method
    private DocumentMetadata.Builder nextItem = null;

    
    public ZipDirToProtos(String zipDirPath) {
        File zipDir = new File(zipDirPath);
        if (zipDir.isDirectory()) {
            listZipFiles = zipDir.listFiles(new ZipFilter());
            zipIndex = 0;
            moveToNextItem();
        } else {
            logger.error(ZipDirToProtos.class.getName() + ": " + zipDirPath + " is not a directory");
        }
    }

    @Override
    public Iterator<DocumentMetadata.Builder> iterator() {
        return new Iterator() {

            @Override
            public boolean hasNext() {
                return nextItem != null;
            }

            @Override
            public DocumentMetadata.Builder next() {
                moveToNextItem();
                return nextItem;
            }

            @Override
            public void remove() {
                moveToNextItem();
            }
        };
    }

    private void moveToNextItem() {

        nextItem = null;

        while (nextItem == null) {
            while (yExportableIterator == null || !yExportableIterator.hasNext()) {
                while (xmlPathIterator == null || !xmlPathIterator.hasNext()) {
                    if (listZipFiles == null || zipIndex >= listZipFiles.length) {
                        nextItem = null;
                        return;
                    }
                    // here we have a new zip file
                    try {
                        actualZipArchive = new ZipArchive(listZipFiles[zipIndex].getPath());
                        xmlPathIterator = actualZipArchive.filter(".*xml").iterator();
                    } catch (IOException ex) {
                        logger.error(ex.toString());
                    }
                    zipIndex++;
                }
                // here we have a new xml path:
                String xmlPath = xmlPathIterator.next();
                try {
                    InputStream xmlIS = actualZipArchive.getFileAsInputStream(xmlPath);
                    yExportableIterator = MetadataPBParser.streamToYExportable(xmlIS, MetadataPBParser.MetadataType.BWMETA).iterator();
                } catch (IOException ex) {
                    logger.error(ex.toString());
                }
            }
            // here we have an yExportable:
            YExportable yExportable = yExportableIterator.next();

            if (yExportable instanceof YElement) {
                YElement yElement = (YElement) yExportable;

                nextItem = MetadataPBParser.yelementToDocumentMetadata(yElement);
                //if not null, this guarantees exit from while loop

                // try to enrich nextItem to media content
                if (nextItem != null) {
                    List<YContentEntry> contents = yElement.getContents();
                    for (YContentEntry content : contents) {
                        InputStream pdfIS = null;
                        try {
                            //TODO: get a pdf path from yElement
                            if (content.isFile()) {
                                // content.getAttributes("lol");
                            }
                            
                            String pdfPath = "(fix_me)not/yet/a/true/path...";
                            pdfIS = actualZipArchive.getFileAsInputStream(pdfPath);
                            // ... do something with pdfIS...
                        } catch (IOException ex) {
                            logger.error(ex.toString());
                        } finally {
                            try {
                                pdfIS.close();
                            } catch (IOException ex) {
                                logger.error(ex.toString());
                            }
                        }
                    }
                }
            }
        }
    }

    private static class ZipFilter implements FilenameFilter {

        @Override
        public boolean accept(File dir, String name) {
            return (name.endsWith(".zip"));
        }
    }
}
